What is a race condition ?

A race condition is a condition when threads that access a shared resource like variables, files,
or databases simulataneously at the same time you have a race condition.

What is a process and a thread in brief ?

A process is an independent program running representing a single instance of a program in
execution. They are heavyweight.

Examples of processes would be a tab with a web browser opened and another with ms word opened.
They dont share the same memory space and  if one crashes another isn't affected.

A thread is the smallest unit of execution within a process and share the same memory space and resources of their parent process
but execute independently


What is synchronization ?

A technique used to control the access of threads to shared resources in concurrent programmming
ensuring that only one thread accesses the resource at a time preventing data inconsistency.

What is interleaving ?

The execution pattern where multiple threads or processes are executed in overlapping time slices, 
resulting in non-deterministic order of operations.

What is interference ? 

A situtation where multiple threads concurrently modify shared resources, leading to inconsistency

What is Mutual Exclusion ?

It is a mechanism that achieves synchronization making sure that it prevents race conditions, 
and maintains data inconsistency and intergrity when multiple threads need to perform operations

What is a Livelock ?

A situation in which threads or processes continously change their states in response to 
each other without making any progress, similar to a deadlock but with active threads

What is a Deadlock ?

A condition where 2 or more threads are blocked forever,each waiting for the other to 
release a resource, resulting in a standstill.

What are the main features of a Semaphore ? What are it's advantages and disadvantages ? Difference between the Mutex, binary and general semaphore ?

A semaphore is a synchronization mechanism that is used to control access to common resources
in a concurrent system.

Semaphores use a counter to keep track of the number of resources available or the number
of permits issued.
General semaphores can have a counter greater than one, allowing a specific number of threads
to access the resource concurrently.
Binary semaphores can only be 0 or 1, similar to a mutex but with differences in usage and
flexibility.

Advantage - resource management and deadlock prevention

Disadvantage - Complexity / potential for misuse






What are the main features of the monitor ? What is the purpose of the while loop in the monitor ?

Another synchronization construct that is used to control access to shared resources where
it ensures that only one thread can execute a particular section of code at a time.
Monitors combine the concept of mutual exclusion with the ability to wait for a certain 
condition to become true.

Monitors provide a way for threads to wait for certain conditions to be met before they proceed. 
This is often implemented using wait(), notify(), and notifyAll() methods in Java.


Purpose of the while loop in monitors - It rechecks the condition ensuring that the thread only
proceeds when the condition is genuinely satisfied.




What is the dining philosopher problem and how is it solved ?

What is the producer problem and how is it solved in brief ?

What is the reader and writer problem and how is it solved ?

Describe the FSP abstract model of a process.

Why is a Java thread described as a lightweight process ?

If several threads are waiting in a queue to get executed how does the JVM decide on which one to execute next ?

When multiple threads are waiting to get executed the JVM decided on deciding which thread gets executed first by
priority and threads could have a priority scale from one to 10 with 5 begin the normal priority.
1 being the minimum priority and 10 being max priority.

Priority doesnt also determine or gurantee the execution of threads always.

Fairness and starvation prevention is considered by the JVM where each thread has to get executed.

The OS has something called as time sclicing where the lower priority threads are given a chance to 
execute over the higher priority ones.

How to remember program after program>>>

Threads Basics

3 classes - MyThread / MyRunnable / ThreadsDemo

Both the classes MyThread and MyRunnable have things in common that could be done in one and copied to the other 

public class MyRunnable implements Runnable{
    public void run(){
            for (int i=0; i<10; i++){
                System.out.println(Thread.currentThread().getName() + " implemented by: " + i);
                try{
                    Thread.sleep(1000);
                } catch (InterruptedException e){
                    e.printStackTrace();
                }
            }
    }
}

public class MyThread extends Thread{
    public void run(){
        for (int i =0; i<10; i++){
            System.out.println(Thread.currentThread().getName() + " extended by: " + i);
            try{
                Thread.sleep(1000);
            } catch (InterruptedException e){
                e.printStackTrace();
            }
        }
    }
}

public class ThreadDemo{
    public static void main(String[] args){
        MyThread thread1 = new MyThread();
        Thread thread2 = new Thread(new MyRunnable());

        thread1.start();
        thread2.start();

        for (int i=0; i<5; i++){
            System.out.println("Main Thread: "+ i);
            try{
                Thread.sleep(1000);
            } catch (InterruptedException e){
                e.printStackTrace();
            }
        }
    }
}

Thread Transitions

There are 2 classes - MyRunnable class and ThreadStateExamples (Main class)

In MyRunnable class within the for loop we have a synchronized (this) block and there are 2 (try catch) one to displat timed waiting and the other to display waiting with wait()

public class MyRunnable implements Runnable{
    @Override
    public void run(){
        for (int i=0; i<10; i++){
            synchronized(this){
                try{
                    Thread.sleep(1000);
                } catch (InterruptedExcetion e){
                    e.printStackTrace();
                }

                try{
                    wait();
                } catch (InterruptedException e){
                    e.printStackTrace();
                }
            }
        }
    }
}

First we create the myRunnable instance from the class MyRunnable that has the run method and pass the instance to the Thread
Display that the thread is in the NEW state
Display that the thread is in the RUNNABLE state after starting the thread
then everything goes into a try-catch block (
    put the thread to sleep for 1sec
    print that it is in TIMED_WAITING state
    then synchronized(myRunnable){
        myRunnable.notify(); //notify that the thread is in the waiting state
    }

    Then put the thread once again to sleep

    call thread.join(); to wait for the thread to finish

    print the terminated state

)

public class ThreadStatesExample{
    public static void main(String[] args){
        MyRunnable myRunnable = new MyRunnable();
        Thread thread = new Thread(myRunnable);

        //NEW state
        System.out.println("The thread is currently not started but created and is in the : " + thread.getState());

        thread.start();
        //Runnable state
        System.out.println("The thread has started and is in the runnable state: " + thread.getState());

        try{
            Thread.sleep(1000);

            System.out.println("The thread is in the sleeping state: " + thread.getState());


            synchronized (myRunnable){
                myRunnable.notify();
            }

            Thread.sleep(1000);

            System.out.println("The thread is notified: " + thread.getState());

            thread.join(); //Wait for the thread to finish 

            System.out.println("The thread is terminated and is in the : " + thread.getState());
        } catch (InterruptedException e){
            e.printStackTrace();
        }
    }
}

state to transition - New -> Runnable -> Timed waiting -> waiting -> terminated


-----------------Thread Groups ---------------------

Has 2 classes - MyRunnable / ThreadGroupExample

public class MyRunnable implements Runnable{
    @Override
    public void run(){
        try{
            while (true){
                System.out.println(Thread.currentThread().getName() + " is running");
                Thread.sleep(2000);
            }
        } catch (InterruptedException e){
            System.out.println(Thread.currentThread().getName()+ " was interrupted");
        }
    }
}

public class ThreadGroupExample{
    public static void main(String[] args){
        ThreadGroup threadGroup = new ThreadGroup("Parent Group");

        //Create a child group
        ThreadGroup childGroup = new ThreadGroup("Child Group");

        Thread t1 = new Thread(parentGroup, new MyRunnable(), "Thread-1);
        Thread t2 = new Thread(parentGroup, new MyRunnable(), "Thread-2);

        t1.start();
        t2.start();

        Thread t3 = new Thread(childGroup, new MyRunnable(), "Thread-3");
        Thread t4 = new Thread(childGroup, new MyRunnable(), "Thread-4");

        t3.start();
        t4.start();

        System.out.println("Active threads in: "+ parentGroup.getName() + " : " + parentGroup.activeCount());
        System.out.println("Active threads in: " + childGroup.getName() + " : " + childGroup.activeCount());

        parentGroup.interrupt();
    }
}

The methods to remember in this program are the activeCount() and the interrupt()
After creating the ThreadGroup, create the Thread with calling the object from
the ThreadGroup with the MyRunnable() and then make sure to start the thread
Use the getName() function when you need to get the name of the thread
